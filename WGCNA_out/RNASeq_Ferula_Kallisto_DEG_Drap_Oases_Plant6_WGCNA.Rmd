title: "RNASeq_Ferula_Kallisto_DEG_Drap_Oases_Plant6_WGCNA"
output: 
  html_document: 
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#This script is all function that I have run for Gene Networking. Present the result in GM but then noticed is not correct for my dataset.

#first start with DEgenes of Drap_Oases_Plant6

```{r}
library(WGCNA)
library(DESeq2)
library(tidyverse); library(limma)
```

#import input from Kallisto_out folder

```{r}
counts_ALL <- read.csv("../Kallisto_out/picked_genes_diff_expr.withexpre.v2", header = F , row.names=1)
dim(counts_ALL) # 11777
colnames(counts_ALL) <- c("DS6","DF6","DL6","DR3","DS3","DF3","DL3","DR2","DS2","DF2","DL2","DR6","NF3","NF6","NR3","NR6","BR3","BF3")

# Filter out feature if there are less than 100 reads in more than 90% of samples
#filtered.counts <- counts_ALL[rowSums(counts_ALL<100)<18,]
```

# Splitting the samples into different tissues types

```{r}
leaf <- counts_ALL[,c(3, 7, 11)]
stem <- counts_ALL[,c(1, 5, 9)]
root <- counts_ALL[,c(4, 8, 12, 15, 16, 17)]
flower <- counts_ALL[,c(2, 6, 10, 13, 14, 18)]
```

# Normalizing function

```{r}
leafvoom = t(voom(leaf)$E)
stemvoom = t(voom(stem)$E)
rootvoom = t(voom(root)$E)
flowervoom = t(voom(flower)$E)
```

# Checks for genes and samples with too many missing values, not have missing value

```{r}
#since samples with not missing values so leafvoom, stemvoom, rootvoom and flowervoom equal to datExpr0

datExpr0root = as.data.frame((rootvoom));
rownames(datExpr0root) #number of the samples
nSamples <- nrow(datExpr0root) #6
nGenes <- ncol(datExpr0root) #11778

gsg = goodSamplesGenes(datExpr0root) 
gsg$allOK #TRUE If the last statement returns TRUE, all genes have passed the cuts

datExpr0leaf = as.data.frame((leafvoom))
nSamples <- nrow(datExpr0leaf) #3
datExpr0stem = as.data.frame((stemvoom))
nSamples <- nrow(datExpr0stem) #3
datExpr0flower = as.data.frame((flowervoom))
nSamples <- nrow(datExpr0flower) #6
#The variables datExpr0flower, datExpr0leaf, datExpr0root, datExpr0stem,  now contains the expression data ready for network analysis
save(counts_ALL, datExpr0flower, datExpr0leaf, datExpr0root, datExpr0stem,leafvoom, stemvoom, rootvoom, flowervoom, file = "dataInput.RData")
```

```{r}
#Once you have comparable data, you need to limit your analysis to genes/probes that are expressed in both data sets, our result are from edgeR so no need to run this step
#commonGenesB = intersect (rownames(datExprB1g),rownames(datExprB2g))
#datExprB1g = datExprB1g[commonGenesB,]
#datExprB2g = datExprB2g[commonGenesB,]
```

# We work with four sets, 

```{r}
#since samples with not missing values so leafvoom, stemvoom, rootvoom and flowervoom equal to datExpr0, we can use multiExpr instead of datExpr0
nSet <- 4
# For easier labeling of plots, create a vector holding descriptive names of the four sets.
setLabels = c("Leaf", "Stem", "Root", "Flower")
shortLabels = setLabels

# Form multi-set expression data
multiExpr = vector(mode = "list", length = nSets)

multiExpr[[1]] = list(data = as.data.frame(leafvoom))
names(multiExpr[[1]]$data) = colnames(leafvoom)
rownames(multiExpr[[1]]$data) = rownames(leafvoom)
nSamples <- nrow(multiExpr[[1]]$data) #3
nGenes <- ncol(multiExpr[[1]]$data) #11778

multiExpr[[2]] = list(data = as.data.frame(stemvoom))
names(multiExpr[[2]]$data) = colnames(stemvoom)
rownames(multiExpr[[2]]$data) = rownames(stemvoom)
nSamples <- nrow(multiExpr[[2]]$data) #3
nGenes <- ncol(multiExpr[[2]]$data) #11778

multiExpr[[3]] = list(data = as.data.frame(rootvoom))
names(multiExpr[[3]]$data) = colnames(rootvoom)
rownames(multiExpr[[3]]$data) = rownames(rootvoom)
nSamples <- nrow(multiExpr[[3]]$data) #6
nGenes <- ncol(multiExpr[[3]]$data) #11778

multiExpr[[4]] = list(data = as.data.frame(flowervoom))
names(multiExpr[[4]]$data) = colnames(flowervoom)
rownames(multiExpr[[4]]$data) = rownames(flowervoom)
nSamples <- nrow(multiExpr[[4]]$data) #6
nGenes <- ncol(multiExpr[[4]]$data) #11778

# Check that the data has the correct format for many functions operating on multiple sets
exprSize = checkSets(multiExpr)
```

#Check the cluster of the samples (gene clustering will be later)

```{r}
sampleTrees = list()
for (set in 1:nSets) {
  sampleTrees[[set]] = hclust(dist(multiExpr[[set]]$data), method = "average")
}
pdf(file = "Plot/SampleClustering.pdf", width = 12, height = 12);
par(mfrow=c(2,1))
par(mar = c(0, 4, 2, 0))
for (set in 1:nSets)
  plot(sampleTrees[[set]], main = paste("Sample clustering on all genes in", setLabels[set]),
    xlab="", sub="", cex = 0.7);
dev.off();
```

#Plot to see what soft-thresholding powers would be appropriate

```{r}
# Choose a set of soft-thresholding powers
powers = c(seq(4,10,by=1), seq(12,20, by=2))

# Initialize a list to hold the results of scale-free analysis
powerTables = vector(mode = "list", length = nSets)

# Call the network topology analysis function for each set in turn
#The aim of pickSoftThreshold function is to help the user pick an appropriate soft-thresholding power for network construction
for (set in 1:nSets)
powerTables[[set]] = list(data = pickSoftThreshold(multiExpr[[set]]$data, powerVector=powers, verbose = 2)[[2]])
collectGarbage()

# Plot the results:
colors = c("yellow", "red", "blue", "green", "black")

# Will plot these columns of the returned scale free analysis tables
plotCols = c(2,5,6,7)
colNames = c("Scale Free Topology Model Fit", "Mean connectivity", "Median connectivity",
"Max connectivity")

# Get the minima and maxima of the plotted points
ylim = matrix(NA, nrow = 2, ncol = 4);
for (set in 1:nSets) {
  for (col in 1:length(plotCols)) {
    ylim[1, col] = min(ylim[1, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE);
    ylim[2, col] = max(ylim[2, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE);
  }
}
```

# Plot the quantities in the chosen columns vs. the soft thresholding power

```{r}
sizeGrWindow(8, 6)
pdf(file = "Plot/scaleFreeAnalysis.pdf", wi = 8, he = 6)
par(mfcol = c(2,2));
par(mar = c(4.2, 4.2 , 2.2, 0.5))
cex1 = 0.7;
for (col in 1:length(plotCols)) for (set in 1:nSets) {
  if (set==1) {
    plot(powerTables[[set]]$data[,1], -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
        xlab="Soft Threshold (power)",ylab=colNames[col],type="n", ylim = ylim[, col],
        main = colNames[col]);
    addGrid();
  }
  if (col==1) {
    text(powerTables[[set]]$data[,1], -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
        labels=powers,cex=cex1,col=colors[set]);
  } else
  text(powerTables[[set]]$data[,1], powerTables[[set]]$data[,plotCols[col]],
      labels=powers,cex=cex1,col=colors[set]);
  if (col==1) {
    legend("bottomright", legend = setLabels, col = colors, pch = 20) ;
  } else
    legend("topright", legend = setLabels, col = colors, pch = 20) ;
}
dev.off();

```

#One-step network construction and module detection
#Leaf and Shoot do not have enough samples. Try just with flower and root

```{r}
#multiExprFR = vector(mode = "list", length = 2)

#multiExprFR[[1]] = list(data = as.data.frame(rootvoom))
#names(multiExprFR[[1]]$data) = colnames(rootvoom)
#rownames(multiExprFR[[1]]$data) = rownames(rootvoom)

#multiExprFR[[2]] = list(data = as.data.frame(flowervoom))
#names(multiExprFR[[2]]$data) = colnames(flowervoom)
#rownames(multiExprFR[[2]]$data) = rownames(flowervoom)

#save(multiExprFR, file = "multiExprFR.RData");  #get number of module and number of genes for each module
```

#building net for root and flower together by power=10 instead of 6

```{r}
#net = blockwiseConsensusModules(
        multiExprFR, power = 10, minModuleSize = 30, deepSplit = 2, 
        pamRespectsDendro = FALSE, 
        mergeCutHeight = 0.25, numericLabels = TRUE, 
        minKMEtoStay = 0,
        saveTOMs = TRUE, verbose = 5)

#table(net$colors)
```


##Start with Tutorial_Document_Main_WGCNA (meta-analysis)

```{r}
#compare two network (root versus flower)
#fisrt correlating general network properties
#root
datExprroot <- t(datExpr0root) #change the row and column
softPower = 10 
rankExprR= rank(rowMeans(datExprroot))
random5000= sample(rownames(datExprroot),5000)
rankConnR= rank(softConnectivity(t(datExprroot[random5000,]),type="signed",power=softPower))

#flower
datExprflower <- t(datExpr0flower) #change the row and column row must be geneID and column samples
softPower = 10 
rankExprF= rank(rowMeans(datExprflower))
random5000= sample(rownames(datExprflower),5000)
rankConnF= rank(softConnectivity(t(datExprflower[random5000,]),type="signed",power=softPower))

pdf("Plot/generalNetworkProperties.pdf", height=10, width=9)
par(mfrow=c(1,2))
verboseScatterplot(rankExprR,rankExprF, xlab="Ranked Expression (R)", 
ylab="Ranked Expression (F)")
verboseScatterplot(rankConnR,rankConnF, xlab="Ranked Connectivity (R)", 
ylab="Ranked Connectivity (F)")

dev.off()
#Notice three things:
#1) The correlations are positive and the p-values are significant in all cases.  This suggests that the data sets are comparable.
#2) The correlations and p-values are better for expression than for connectivity.  This is consistent with many studies.

#So computational reasons and for simplicity we can first will choose the top 5000 most expressed genes in data set (see the Tutorial doc). but for now I keep all of them.

#Next, we will calculate all of the necessary values to run WGCNA.  

adjacencyR = adjacency(t(datExprroot),power=softPower,type="signed");
diag(adjacencyR)=0
dissTOMR   = 1-TOMsimilarity(adjacencyR, TOMType="signed")
install.packages("flashClust")
library(flashClust)
geneTreeR  = flashClust(as.dist(dissTOMR), method="average")

adjacencyF = adjacency(t(datExprflower),power=softPower,type="signed");
diag(adjacencyF)=0
dissTOMF   = 1-TOMsimilarity(adjacencyF, TOMType="signed")
geneTreeF  = flashClust(as.dist(dissTOMF), method="average")

save.image("tutorial.RData")  #  (Section will take ~5-15 minutes to run),This file will be ~700GB and is not required, but if your computer crashes, you can type:
#load("tutorial.RData") to restart at this point.  


# display the networks visually
sizeGrWindow(6,16)
pdf("Plot/dendrogram.pdf",height=6,width=16)
par(mfrow=c(1,2))
plot(geneTreeR,xlab="",sub="",main="Gene clustering on TOM-based dissimilarity (R)", labels=FALSE,hang=0.04);
plot(geneTreeF,xlab="",sub="",main="Gene clustering on TOM-based dissimilarity (F)", labels=FALSE,hang=0.04); 
dev.off()
#while (!is.null(dev.list())) dev.off() # run when got this error"Error in dev.off() : cannot shut down device 1 (the null device)"
#These are "good" data, since there are a lot of distinct branches

#Next we will determine modules based on data set R (in a real situation, you would usually determine modules in your "control" data set).  We use this code to automatically display four different module splits that we can choose from.

mColorh=NULL
for (ds in 0:3){
 tree = cutreeHybrid(dendro = geneTreeR, pamStage=FALSE,
   minClusterSize = (30-3*ds), cutHeight = 0.99, 
   deepSplit = ds, distM = dissTOMR)
 mColorh=cbind(mColorh,labels2colors(tree$labels));
}
pdf("Plot/Module_choices.pdf", height=10,width=25); 
plotDendroAndColors(geneTreeR, mColorh, paste("dpSplt =",0:3), main = "",dendroLabels=FALSE);
dev.off()
modulesR =  mColorh[,1] # (Chosen based on plot below)
#I chose to use deepsplit=0 (the top row) so that there will be a small number of large modules.  Depending on the purpose of the analysis, it is sometimes preferable to choose a larger number of small modules—in such a case, deepsplit values of 1-3 would be chosen.

#Next we calculate the principle components for visualizations 
#The first PC is referred to as the module eigengene (ME), and is a single value that represents the highest percent of variance for all genes in a module.  In other words, if we show the ME for module X doing something, there is a good chance that most genes in module X also do that same thing.

PCs1R    = moduleEigengenes((datExprroot), colors= modulesR) 
ME_1R    = PCs1R$eigengenes
distPC1R = 1-abs(cor(ME_1R,use="p"))
distPC1R = ifelse(is.na(distPC1R), 0, distPC1R)
pcTree1R = hclust(as.dist(distPC1R),method="a") 
MDS_1R   = cmdscale(as.dist(distPC1R),2)
colorsR = names(table(modulesR))

save.image("tutorial.RData")

pdf("Plot/ModuleEigengeneVisualizations.pdf",height=6,width=6)
par(mfrow=c(1,1), mar=c(4, 5, 2, 2) + 0.1, cex=1)

plot(pcTree1R, xlab="",ylab="",main="",sub="")

plot(MDS_1R, col= colorsR,  main="MDS plot", cex=2, pch=19)

ordergenes = geneTreeR$order
plotMat(scale(log(datExprroot[ordergenes,])) , rlabels= modulesR[ordergenes], clabels= colnames(datExprroot), rcols=modulesR[ordergenes])

for (which.module in names(table(modulesR))){
  ME = ME_1R[, paste("ME",which.module, sep="")] 
  barplot(ME, col=which.module, main="", cex.main=2, 
      ylab="eigengene expression",xlab="array sample") 
}; 

dev.off();
#The first box is a dendrogram of the module eigengenes: modules in the same branches have relatively similar expression (but not as similar as the expression of genes within a single module).  The second box is a multidimensional scaling (MDS) plot of the module eigengene, where the x-axis is the first PC and the y-axis is the second PC: modules that group together have relatively similar expression. The third plot is a heat map of all of the genes sorted as they were clustered above (y-axis).  Each column represents a sample (x-axis), which could be sorted based on phenotypic information or based on clustering, but in this case aren't sorted at all. Finally, the last plot shows the ME expression for all modules. As with the heat map, the samples (bars) could be ordered and labeled, but aren't.

#Qualitatively and quantitatively measure network preservation at the module level.
#Now that we have all of our WGCNA variables as well as our module definitions, we can start assessing how well our modules in network R are preserved in network F. As a qualitative assessment, we impose the modules from R on the network for data set F, and then plot the resulting networks.

pdf("Plot/Final_modules.pdf",height=8,width=12)
plotDendroAndColors(geneTreeR, modulesR, "Modules", dendroLabels=FALSE, hang=0.03, addGuide=TRUE, 
guideHang=0.05, main="Gene dendrogram and module colors (R)") 
plotDendroAndColors(geneTreeF, modulesR, "Modules", dendroLabels=FALSE, hang=0.03, addGuide=TRUE, 
guideHang=0.05, main="Gene dendrogram and module colors (F)") 
dev.off()

#We can see from the fact that these module labels still group together in R (up) that there is very good preservation.  It is important to note that it is often not possible to see an obvious grouping of model labels in the second data set, even if there is significant module preservation.  

#To quantify this result, we take advantage of another function built into the WGCNA library: modulePreservation.  This function assesses how well a module in one study is preserved in another study using a number of strategies and (for the purposes of this tutorial) outputs a single Z-score summary.
```

```{r}

#scripts from MiniTutorial-MouseLiver.pdf

# (This step will take ~10-30 minutes)

multiExpr  = list(R=list(data=t(datExprroot)),F=list(data=t(datExprflower)))
multiColor = list(R = modulesR)
mp=modulePreservation(multiExpr,multiColor,referenceNetworks=1,verbose=3,networkType="signed",
nPermutations=30,maxGoldModuleSize=100,maxModuleSize=400)
# Save the results
save(mp, file = "modulePreservation.RData");


#Analysis and display of module preservation results
ref = 1 #root
test = 2 #flower assign these two number for visulization.$Z$[[ref]] same as $Z$ref.R$
statsObs = cbind(mp$quality$observed[[ref]][[test]][, -1], mp$preservation$observed[[ref]][[test]][, -1])
statsZ = cbind(mp$quality$Z[[ref]][[test]][, -1], mp$preservation$Z[[ref]][[test]][, -1]);
#or
stats = mp$preservation$Z$ref.R$inColumnsAlsoPresentIn.F #same as statsZ
stats[order(-stats[,2]),c(1:2)]
#The output on the screen will look like this:
#In general, the higher the value of "Zsummary.pres" the more preserved the module is between data sets: 5<Z<10 indicates moderate preservation, while Z>10 indicates high preservation. 
#moduleSize Zsummary.pres
#turquoise        400     11.411364
#blue             400     10.995776
#gold             100      8.408790
#red              196      4.767202
#green            249      3.068314
#black            162      2.412546
#brown            400      1.297409
#grey             400     -1.155836
#yellow           364     -1.656609

#We look at the main output: the preservation medianRank and Zsummary statistics.
# Compare preservation to quality:

print( cbind(statsObs[, c("medianRank.pres", "medianRank.qual")],
signif(statsZ[, c("Zsummary.pres", "Zsummary.qual")], 2)) )
#          medianRank.pres medianRank.qual Zsummary.pres Zsummary.qual
#black                   5               3           2.4          35.0
#blue                    2               4          11.0          44.0
#brown                   7               6           1.3          47.0
#gold                    3               8           8.4           0.5
#green                   4               2           3.1          39.0
#grey                    9               9          -1.2           6.9
#red                     4               1           4.8          44.0
#turquoise               2               5          11.0          54.0
#yellow                  8               7          -1.7          48.0

#The numbers are nice, but (to paraphrase a saying) a picture is worth a thousand numbers. We plot the preservation medianRank and Zsummary for the female modules as a function of module size. The plotting code may seem a bit involved, but it is worth going through.

# Module labels and module sizes are also contained in the results
modColors = rownames(mp$preservation$observed[[ref]][[test]])
moduleSizes = mp$preservation$Z[[ref]][[test]][, 1];
# leave some modules out
#plotMods = !(modColors %in% c("grey", "gold")); 
plotMods = (modColors %in% c("black", "blue", "brown", "gold", "green", "grey", "red" ,"turquoise" ,"yellow")) #keep all modules for now

# Text labels for points
text = modColors[plotMods];
# Auxiliary convenience variable
plotData = cbind(mp$preservation$observed[[ref]][[test]][, 2], mp$preservation$Z[[ref]][[test]][, 2])
# Main titles for the plot
mains = c("Preservation Median rank", "Preservation Zsummary");
# Start the plot
sizeGrWindow(10, 5);

pdf("Plot/RootOnly-modulePreservation-Zsummary-medianRanks.pdf", wi=10, h=5)
par(mfrow = c(1,2))
par(mar = c(4.5,4.5,2.5,1))
for (p in 1:2)
{
#min = min(plotData[, p], na.rm = TRUE);
#max = max(plotData[, p], na.rm = TRUE);
# Adjust ploting ranges appropriately
#if (p==2)
#{
#if (min > -max/10) min = -max/10
#ylim = c(min - 0.1 * (max-min), max + 0.1 * (max-min))
#} else
#ylim = c(max + 0.1 * (max-min), min - 0.1 * (max-min))
plot(moduleSizes[plotMods], plotData[plotMods, p], col = 1, bg = modColors[plotMods], pch = 21,
main = mains[p],
cex = 2.4,
ylab = mains[p], xlab = "Module size", log = "x",
ylim = ylim,
xlim = c(10, 2000), cex.lab = 1.2, cex.axis = 1.2, cex.main =1.4)
labelPoints(moduleSizes[plotMods], plotData[plotMods, p], text, cex = 1, offs = 0.08);
# For Zsummary, add threshold lines
if (p==2)
{
abline(h=0)
abline(h=2, col = "blue", lty = 2)
abline(h=10, col = "darkgreen", lty = 2)
}
}
# If plotting into a file, close it
dev.off();
#Figure: The medianRank and Zsummary statistics of module preservation of root modules in flower modules (y-axis) vs. module size (x-axis).
# We find that most strong evidence of preservation for turquoise and blue. The brown, gray and yellow modules whose Zsummary statistics are 2.0 (borderline between no preservation and very weak preservation).


#We now plot the density and connectivity statistics all in one plot. We include the module quality measures for comparison:
# Re-initialize module color labels and sizes
modColors = rownames(statsZ)
moduleSizes = mp$quality$Z[[ref]][[test]][, 1];
# Exclude improper modules
#plotMods = !(modColors %in% c("grey", "gold"));
plotMods = (modColors %in% c("black", "blue", "brown", "gold", "green", "grey", "red" ,"turquoise" ,"yellow")) #keep all modules for now
# Create numeric labels for each module
labs = match(modColors[plotMods], standardColors(50));
# Start the plot: open a suitably sized graphical window and set sectioning and margins.
sizeGrWindow(12, 9);
pdf("Plot/RootOnly-modulePreservation-AllParameterssss.pdf")
par(mfrow = c(3,5))
par(mar = c(3,3,2,1))
par(mgp = c(1.6, 0.4, 0));
# Plot each Z statistic in a separate plot.
for (s in 1:ncol(statsZ))
{
min = min(statsZ[plotMods, s], na.rm = TRUE);
max = max(statsZ[plotMods, s], na.rm = TRUE);
if (min > -max/5) min = -max/5
plot(moduleSizes[plotMods], statsZ[plotMods, s], col = 1, bg = modColors[plotMods], pch = 21,
main = colnames(statsZ)[s],
cex = 1.7,
ylab = colnames(statsZ)[s], xlab = "Module size", log = "x",
ylim = c(min - 0.1 * (max-min), max + 0.1 * (max-min)),
xlim = c(20, 1000))
labelPoints(moduleSizes[plotMods], statsZ[plotMods, s], labs, cex = 0.7, offs = 0.04);
abline(h=0)
abline(h=2, col = "blue", lty = 2)
abline(h=10, col = "darkgreen", lty = 2)
}
dev.off()
#Figure: Statistics of module quality (first row; names end with suffix .qual) and module preservation (second and third row) of rppt modules. Modules are labeled by their color and by numeric labels (see text).
#The translation table between module colors and the numeric labels can be obtained for example as follows:
x <- data.frame(color = modColors[plotMods], label = labs)
#color label
#black	7			
#blue	2			
#brown	3			
#gold	NA			
#green	5			
#grey	NA			
#red	6			
#turquoise	1			
#yellow	4	

#The all quality statistics point to bradly the same conclusion, but they measure different aspects of quality and hence are all somewhat different from each other. Hence the usefulness of the Zsummary statistic. The same can be said about the preservation statistics they are broadly similar but in details they differ, and summary is very useful to form an overall conclusion.
#As a programming/graphics side note, some of the plots illustrate graphically the limitations of the function labelPoints. There are no miracles, not even in WGCNA

#Module membership (kME) and its use in comparing networks
#kME is a useful value, in that it can be used to measure correlations between each gene and each ME, and thus even genes which were not initially assigned to a module can be included in between-network comparisons.  
#We first will get the kME values, along with their associated p-values for R and will then output the resulting table to a file ("kMEtable1.csv").

geneModuleMembershipR = signedKME(t(datExprroot), ME_1R)
colnames(geneModuleMembershipR)=paste("PC",colorsR,".cor",sep=""); 

MMPvalueR=corPvalueStudent(as.matrix(geneModuleMembershipR),dim(datExprroot)[[2]]); 
colnames(MMPvalueR)=paste("PC",colorsR,".pval",sep="");

Gene = rownames(datExprroot)
kMEtableR  = cbind(Gene,Gene,modulesR)
for (i in 1:length(colorsR))
 kMEtableR = cbind(kMEtableR, geneModuleMembershipR[,i], MMPvalueR[,i])
colnames(kMEtableR)=c("PSID","Gene","Module",sort(c(colnames(geneModuleMembershipR), colnames(MMPvalueR))))

write.csv(kMEtableR,"kMEtableR.csv",row.names=FALSE) #focus on this file to see the cor and p-value of all genes in each modules separately.

#Now repeat for F, using the module assignments from R to determine kME values.
# First calculate MEs for F, since we haven't done that yet

PCs2F = moduleEigengenes(t(datExprflower),  colors=modulesR) 
ME_2F = PCs2F$eigengenes

geneModuleMembershipF = signedKME(t(datExprflower), ME_2F)
colnames(geneModuleMembershipR)=paste("PC",colorsR,".cor",sep=""); 

MMPvalueF=corPvalueStudent(as.matrix(geneModuleMembershipF),dim(datExprflower)[[2]]); 
colnames(MMPvalueF)=paste("PC",colorsR,".pval",sep="");

kMEtableF  = cbind(Gene,Gene,modulesR)
for (i in 1:length(colorsR))
 kMEtableF = cbind(kMEtableF, geneModuleMembershipF[,i], MMPvalueF[,i])
colnames(kMEtableF)=colnames(kMEtableR)

write.csv(kMEtableF,"kMEtableF.csv",row.names=FALSE)

#Now that we have kME values for both networks, there are a few additional ways in which we can compare the resulting networks. 

#The first thing we can do is plot the kME values of each gene in R against the corresponding kME values of each gene in F.  Modules with points showing a high correlation are highly preserved. 
#for creating these plots for both all genes

pdf("Plot/all_kMEtableF_vs_kMEtableR.pdf",height=8,width=8)
for (c in 1:length(colorsR)){
 verboseScatterplot(geneModuleMembershipF[,c],geneModuleMembershipR[,c],main=colorsR[c],
                    xlab="kME in F",ylab="kME in R")
}; dev.off()

#the subset of genes originally assigned to a given module
pdf("Plot/inModule_kMEtableF_vs_kMEtableR.pdf",height=8,width=8)
for (c in 1:length(colorsR)){
 inMod = modulesR== colorsR[c]
 verboseScatterplot(geneModuleMembershipF[inMod,c],geneModuleMembershipR[inMod,c],main=colorsR[c],
                    xlab="kME in F",ylab="kME in R")
}; dev.off()
save.image("tutorial.RData") #(optional line of code)

#These two types of plots convey similar, but not identical, information.  Using all genes allows one to include all positively and negatively correlated genes, but often also includes a lot of noise (although not in this case).  Using only in-module genes (right) is a visual way of assessing hub gene conservation: if these genes show between-set correlation, then the genes in the upper right of the plot are likely to be common hub genes between data sets.  (Hub genes are genes that show significant correlation with MEs and high within-module connectivity and will be discussed below.) 

#The second thing we can do is determine which genes are hubs in both networks by determine which genes have extremely high kME values in both networks.
#Hub gene This loosely defined term is used as an abbreviation of “highly connected gene”.

topGenesKME = NULL
for (c in 1:length(colorsR)){
 kMErankR    = rank(-geneModuleMembershipR[,c])
 kMErankF    = rank(-geneModuleMembershipF[,c])
 maxKMErank  = rank(apply(cbind(kMErankR,kMErankF+.00001),1,max))
 topGenesKME = cbind(topGenesKME,Gene[maxKMErank<=10])
}; colnames(topGenesKME) = colorsR
topGenesKME
write.table(topGenesKME,"topGenesKME.txt",sep="\t",row.names=FALSE)
#These genes represent the top 10 genes per module based on kME in both networks.
```


```{r}
#Comparing networks and annotating modules using programs outside of R

#The remainder of this document include methods that involving using R in combination with other methods to compare networks.  This tutorial may be insufficient to complete the parts of this analysis that are done outside of R; similarly, some of these functions (indicated with a comment) should be considered "beta" and are sometimes unreliable.  That said, this step can be taken as a guideline for things to try when comparing multiple networks (or even when analyzing data from a single network).

#In order to visualize our resulting network modules, we can output data from our network for import into VisANT, which is a standalone visualization program that is available at http://visant.bu.edu/.  VisANT will allow you to visually see the hub genes in a module, and is the program that most people in the lab use to make the module pictures that end up in publications. Tutorials for how to use VisANT are available on the website, or you can ask someone. 

source("tutorialFunctions.R")  
for (co in colorsR[colorsR!="grey"])
  visantPrepOverall(modulesR, co, t(datExprroot), rownames(datExprroot), 500, softPower, TRUE)

#This function will output a lot of files into your current directory, which I put into a subfolder called "visantFilesR".  For each module we will have two files:
#1) <module>_connectivityOverall.csv:  this file contains a list of all of the genes in a given module sorted from the highest to the lowest intramodule connectivity (kin), along with their mean expression. So the genes at the top of the list would be hub genes.
#2) <module>_visantOverall.csv: this file contains all of the input we will need for VisANT.  Note that only the first five columns should be copied into VisANT.  The first two columns represent genes that have the highest topological overlap (column 5) in the module.  Column 3 must be "0" and column 4 is the color of the lines to draw ("M1002" is orange).

#same thing for Flower

for (co in colorsR[colorsR!="grey"])
  visantPrepOverall(modulesR, co, t(datExprflower), rownames(datExprflower), 500, softPower, TRUE)

datExprRF = t(cbind(datExprroot,datExprflower))
i1 = 1:dim(datExprroot)[[2]];
i2 = (1:dim(datExprflower)[[2]])+length(i1)
for (co in colorsR[colorsR!="grey"])
  visantPrep(modulesR, co, i1, i2, datExprRF, rownames(datExprroot), 500, softPower, TRUE)

#The output files from this function are similar to those from the previous code, except that the connectivity files include kin for both R and F, and the VisANT file requires some editing before it can be input into VisANT (for example, the "0" and the color columns are missing, and columns A, C, E, F, H, and I are extraneous).  Genes specific to R can be found two ways:
#1) In the connectivity files, genes with high "kin_CI" and low "kin_MS" are only hubs in R.
#2) In the visant files, genes with many connections with "TO_Ratio" are only hubs in R. 

#for GOenrichmentAnalysis use David, there is a function in the WGCNA library called "GOenrichmentAnalysis" that also runs GO enrichment.

#Create a new folder called "geneLists_RF" then run this code:

folder = "geneLists_RF/"
for (c in colorsR){ 
  fn = paste(folder, c, ".txt",sep=""); 
  write.geneList(Gene[modulesR==c], fn) 
};  
write(Gene,paste(folder,"all.txt",sep=""))
#The folder should now have files titled "<color>.txt" that contain the gene names of every gene in that module, as well as a file titled "all.txt" that has every gene in your data set.  This "all.txt" is what we should use as population file when asked in EASE (or DAVID).  In EASE, I would suggest saving  output as an excel file, as that is much easier to work with than the default (which is a website).  Otherwise, EASE is relatively straightforward to use.  

#We can also annotate modules based enrichment for user-defined lists.  GO is a good system for finding genes involved in specific cellular components, biological processes, and molecular functions; however, GO is lacking in its annotation of things like cell-type-specific and disease-related genes.  Furthermore, sometimes it is advantageous to compare our modules to gene lists from related publications, from previous experiments done in the lab, etc.  To do that, input the following code:

enrichments = userListEnrichment(Gene, modulesA1, c("exampleListInput.csv","exampleMMInput.csv"), 
                       c("cellType","humanModules"), "enrichment.csv")

#There are two types of files that are accepted for input into the function "userListEnrichment": 
#1) Gene lists (for example: "exampleListInput.csv"): this type of file must have at least two columns with the column headers "Gene" and "Var1".  The first column should contain gene lists corresponding to user-defined categories, while the second column should have descriptors of these categories.  Any number of categories can be contained in a single file.
#2) Module Membership tables (for example: "exampleMMInput.csv"): this type of file must have at least three columns labeled "PSID", "Gene", and "Module", respectively (the remaining columns are not used).  From these tables, modules are treated as categories.
#Note that all of the category enrichments (both significant and not) are saved in the variable enrichments$pValues. To see which genes in the green module are astrocyte genes, we would type this in R: 

enrichments$ovGenes$'green -- cellType_Astrocyte_Cahoy_all'
# The output is...
# [1] "ACSBG1"        "ADD3"          "ADHFE1"        "AGL"           "AGT"         
# [2] "AGTRL1"        "AGXT2L1"       "AHCYL1"        "AK3"           "ALDH1A1"
# (etc.)

#Here are a few other websites that can be used to annotate modules given a list of genes:

#ChiliBot: 	http://www.chilibot.net/
#WebGestalt: 	http://bioinfo.vanderbilt.edu/webgestalt/
#Ingenuity:	http://www.ingenuity.com/
#Galaxy: 	http://main.g2.bx.psu.edu/
#GSEA: 	http://www.broadinstitute.org/gsea/index.jsp
#UGET:   	http://genome.ucla.edu/projects/UGET
#STRING:	http://string.embl.de/

#Also WGCNA has function for compare samples with different platform
```

#Scaling of Topological Overlap Matrices to make them comparable across sets
#Calculation of network adjacencies

```{r}
#nSets = 2
#Network construction starts by calculating the adjacencies in the individual sets, using the soft thresholding power 10
softPower = 10;
# Initialize an appropriate array to hold the adjacencies
adjacencies = array(0, dim = c(nSets, nGenes, nGenes));
# Calculate adjacencies in each individual data set
for (set in 1:nSets)
adjacencies[set, , ] = abs(cor(multiExpr[[set]]$data, use = "p"))^softPower;

#Calculation of Topological Overlap

#We now turn the adjacencies into Topological Overlap Matrix (TOM) 
# Initialize an appropriate array to hold the TOMs
TOM = array(0, dim = c(nSets, nGenes, nGenes));
# Calculate TOMs in each individual data set
for (set in 1:nSets)
TOM[set, , ] = TOMsimilarity(adjacencies[set, , ]);
#Define the reference percentile
scaleP = 0.95
# Set RNG seed for reproducibility of sampling
set.seed(12345)
# Sample sufficiently large number of TOM entries
nSamples <- nrow(multiExpr[[set]]$data)
nSamples = as.integer(1/(1-scaleP) * 1000);
# Choose the sampled TOM entries
scaleSample = sample(nGenes*(nGenes-1)/2, size = nSamples)
TOMScalingSamples = list();
# These are TOM values at reference percentile
scaleQuant = rep(1, nSets)
# Scaling powers to equalize reference TOM values
scalePowers = rep(1, nSets)
# Loop over sets
for (set in 1:nSets)
{
# Select the sampled TOM entries
TOMScalingSamples[[set]] = as.dist(TOM[set, , ])[scaleSample]
# Calculate the 95th percentile
scaleQuant[set] = quantile(TOMScalingSamples[[set]],
probs = scaleP, type = 8);
# Scale the male TOM
if (set>1)
{
scalePowers[set] = log(scaleQuant[1])/log(scaleQuant[set]);
TOM[set, ,] = TOM[set, ,]^scalePowers[set];
}
}

#The array TOM now contains the scaled TOMs. To see what the scaling achieved, we form a quantile-quantile plot of the root and flower topological overlaps before and after scaling:
# For plotting, also scale the sampled TOM entries
scaledTOMSamples = list();
for (set in 1:nSets)
scaledTOMSamples[[set]] = TOMScalingSamples[[set]]^scalePowers[set]
# Open a suitably sized graphics window
sizeGrWindow(8,8)
pdf(file = "Plot/TOMScaling-QQPlot.pdf", wi = 8, he = 8);
qqUnscaled = qqplot(TOMScalingSamples[[1]], TOMScalingSamples[[2]], plot.it = TRUE, cex = 0.6,
xlab = paste("TOM in", setLabels[1]), ylab = paste("TOM in", setLabels[2]),
main = "Q-Q plot of TOM", pch = 20)
# qq plot of the scaled samples 
qqScaled = qqplot(scaledTOMSamples[[1]], scaledTOMSamples[[2]], plot.it = FALSE)
points(qqScaled$x, qqScaled$y, col = "red", cex = 0.6, pch = 20);

abline(a=0, b=1, col = "blue")
legend("topleft", legend = c("Unscaled TOM", "Scaled TOM"), pch = 20, col = c("black", "red"))
dev.off();
#In this case the scaling changed the root TOM only very slightly, and brought it closer to the reference line shown in blue.
#Quantile-quantile plot of the TOMs in root and flower data sets. The black points are TOMs before scaling, the red points are TOMs after scaling. The closer the points lie to the reference line shown in blues, the closer is the distribution of the TOM values in the two data sets.
```

#Calculation of consensus Topological Overlap to check the merge module works or not

```{r}
#We now calculate the consensus Topological Overlap by taking the component-wise (“parallel”) minimum of theTOMs in individual sets:

consensusTOM = pmin(TOM[1, , ], TOM[2, , ]);
#Thus, the consensus topological overlap of two genes is only large if the corresponding entries in the two sets are also large.

#Clustering and module identification 
#We use the consensus TOM as input to hierarchical clustering, and identify modules in the resulting dendrogram using the Dynamic Tree Cut algorithm

consTree = hclust(as.dist(1-consensusTOM), method = "average");
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 30;
# Module identification using dynamic tree cut:
unmergedLabels = cutreeDynamic(dendro = consTree, distM = 1-consensusTOM,
deepSplit = 2, cutHeight = 0.995,
minClusterSize = minModuleSize,
pamRespectsDendro = FALSE );
unmergedColors = labels2colors(unmergedLabels)

#To see a quick summary of the module detection, we use table(unmergedLabels):
table(unmergedLabels)
unmergedLabels
#The Dynamic Tree Cut returned 125 proper modules with sizes ranging from 1309 to 33 genes. The label 0 is reserved for genes not assigned to any of the modules. The following code plots the consensus gene dendrogram together with the preliminary module colors:

sizeGrWindow(8,6)
pdf(file = "Plot/DynamicTreeCut.pdf", wi = 8, he = 6)
plotDendroAndColors(consTree, unmergedColors, "Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
dev.off()

#Merging of modules whose expression profiles are very similar
#The Dynamic Tree Cut may identify modules whose expression profiles are very similar. It may be prudent to merge such modules since their genes are highly co-expressed. To quantify co-expression similarity of entire modules, we calculate their eigengenes (MEs) and cluster them on their consensus correlation, that is the minimum correlation across the two sets:

# Calculate module eigengenes

unmergedMEs = multiSetMEs(multiExpr, colors = NULL, universalColors = unmergedColors)
# Calculate consensus dissimilarity of consensus module eigengenes
consMEDiss = consensusMEDissimilarity(unmergedMEs);
# Cluster consensus modules
consMETree = hclust(as.dist(consMEDiss), method = "average");
# Plot the result
sizeGrWindow(20,6)
par(mfrow = c(1,1))
pdf(file = "Plot/DynamicTreeCut2.pdf", wi = 20, he = 6)
plot(consMETree, main = "Consensus clustering of consensus module eigengenes",
xlab = "", sub = "")
abline(h=0.25, col = "red")
dev.off()
#Figure : Gene dendrogram obtained by clustering based on the consensus topological overlap across root and flower. The identified preliminary modules are indicated in the color row beneath the dendrogram.

#One pair of modules falls below the merging threshold. The merging can be performed automatically:

merge = mergeCloseModules(multiExpr, unmergedLabels, cutHeight = 0.25, verbose = 3)
#The variable merge contains various information; we will need the following:
# Numeric module labels
moduleLabels = merge$colors;
# Convert labels to colors
moduleColors = labels2colors(moduleLabels)
# Eigengenes of the new merged modules:
consMEs = merge$newMEs;
#Lastly, we plot the gene dendrogram again, this time with both the unmerged and the merged module colors:
sizeGrWindow(12,6)
pdf(file = "Plot/ConsTreeUnmergedMerged.pdf", wi = 12, he = 6)
plotDendroAndColors(consTree, cbind(unmergedColors, moduleColors),
c("Unmerged", "Merged"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
dev.off()
#Gene dendrogram obtained by clustering the dissimilarity based on consensus Topological Overlap. The two color rows show the preliminary (unmerged) and the final, merged module assignments

# We now save the information necessary in the subsequent parts of the tutorial:
save(consMEs, moduleColors, moduleLabels, consTree, file = "Consensus-NetworkConstruction-man.RData") 
```

#Exporting to Cytoscape???

```{r}

# Recalculate topological overlap if needed
TOM = TOMsimilarityFromExpr(datExpr0root, power = 10);
# Read in the annotation file
#annot = read.csv(file = "GeneAnnotation.csv");
# Select modules based on what???
modules = c("brown", "red");
# Select module probes
probes = names(datExpr0root)
inModule = is.finite(match(moduleColors, modules));
modProbes = probes[inModule];
#modGenes = annot$gene_symbol[match(modProbes, annot$substanceBXH)]; skip this
# Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modProbes, modProbes)
# Export the network into edge and node list files Cytoscape can read
cyt = exportNetworkToCytoscape(modTOM,
edgeFile = paste("CytoscapeInput-edges-", paste(modules, collapse="-"), ".txt", sep=""),
nodeFile = paste("CytoscapeInput-nodes-", paste(modules, collapse="-"), ".txt", sep=""),
weighted = TRUE,
threshold = 0.02,
nodeNames = modProbes,
#altNodeNames = modGenes,
nodeAttr = moduleColors[inModule]); # what should I do now for visulize???
```

#Exporting to VisANT

```{r}
# Recalculate topological overlap
TOM = TOMsimilarityFromExpr(datExpr0root, power = 10);
# Read in the annotation file
#annot = read.csv(file = "GeneAnnotation.csv");
# Select module
module = "brown";
# Select module probes
probes = names(datExpr0root)
inModule = (moduleColors==module);
modProbes = probes[inModule];
# Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modProbes, modProbes)
# Export the network into an edge list file VisANT can read
vis = exportNetworkToVisANT(modTOM,
file = paste("VisANTInput-", module, ".txt", sep=""),
weighted = TRUE,
threshold = 0,
#probeToGene = data.frame(annot$substanceBXH, annot$gene_symbol) )
nTop = 30;
IMConn = softConnectivity(datExpr[, modProbes]);
top = (rank(-IMConn) <= nTop)
vis = exportNetworkToVisANT(modTOM[top, top],
file = paste("VisANTInput-", module, "-top30.txt", sep=""),
weighted = TRUE,
threshold = 0,
#probeToGene = data.frame(annot$substanceBXH, annot$gene_symbol) )
```



```{r}
##scripts from https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Consensus-DataInput.pdf

leaf <- counts_ALL[,c(3, 7, 11)]
stem <- counts_ALL[,c(1, 5, 9)]
root <- counts_ALL[,c(4, 8, 12, 15, 16, 17)]
flower <- counts_ALL[,c(2, 6, 10, 13, 14, 18)]

leafvoom = t(voom(leaf)$E)
stemvoom = t(voom(stem)$E)
rootvoom = t(voom(root)$E)
flowervoom = t(voom(flower)$E)

rootvoom <- t(rootvoom) # #Note that each row corresponds to a gene then put the expression data into a multi-set format suitable for consensus analysis.
dim(rootvoom) #11778     6
flowervoom <- t(flowervoom)
dim(flowervoom) #11778     6
# We work with two sets:
nSets = 2;
# For easier labeling of plots, create a vector holding descriptive names of the two sets.
setLabels = c("Root", "Flower")
shortLabels = c("Root", "Flower")

multiExpr = vector(mode = "list", length = nSets)
multiExpr[[1]] = list(data = as.data.frame(t(rootvoom))); #set as a root data
names(multiExpr[[1]]$data) ;
rownames(multiExpr[[1]]$data);
multiExpr[[2]] = list(data = as.data.frame(t(flowervoom)));
names(multiExpr[[2]]$data) ;
rownames(multiExpr[[2]]$data) ;
# Check that the data has the correct format for many functions operating on multiple sets:
exprSize = checkSets(multiExpr)
#$nSets
#[1] 2

#$nGenes
#$[1] 11778

#$nSamples
#[1] 6 6

#$structureOK
#[1] TRUE

# Check that all genes and samples have sufficiently low numbers of missing values.
#gsg = goodSamplesGenesMS(multiExpr, verbose = 3);
#gsg$allOK
traitData = read.csv("Metabolite_Traits.csv"); #also put this .csv in Metabolome_Experiment_UCDavis folder
#seperate two files based on the unit of matabolite
traitDataCoumarin <-traitData[ ,c(1:2,4)] #remove UMP because all of them is zero
traitDataTerpen <-traitData[ ,c(1, 5:8)]
# See how big the traits are and what are the trait and sample names
dim(traitDataCoumarin) #18 3
names(traitDataCoumarin)
names(traitDataTerpen) 
dim(traitDataTerpen) #18 5 
traitDataCoumarin$Sample
traitDataTerpen$Sample
# Form a multi-set structure that will hold the Coumarin traits.
TraitsCoumarin = vector(mode="list", length = nSets);
for (set in 1:nSets)
{
setSamples = rownames(multiExpr[[set]]$data);
traitRowsCoumarin = match(setSamples, traitDataCoumarin$Sample);
TraitsCoumarin[[set]] = list(data = traitDataCoumarin[traitRowsCoumarin, -1]);
rownames(TraitsCoumarin[[set]]$data) = traitDataCoumarin[traitRowsCoumarin, 1];
}
collectGarbage();

# Form a multi-set structure that will hold the Terpen traits.
TraitsTerpen = vector(mode="list", length = nSets);
for (set in 1:nSets)
{
setSamples = rownames(multiExpr[[set]]$data);
traitRowsTerpen = match(setSamples, traitDataTerpen$Sample);
TraitsTerpen[[set]] = list(data = traitDataTerpen[traitRowsTerpen, -1]);
rownames(TraitsTerpen[[set]]$data) = traitDataTerpen[traitRowsTerpen, 1];
}
collectGarbage();
# Define data set dimensions
nGenes = exprSize$nGenes;
nSamples = exprSize$nSamples;

#We now cluster the samples on their Euclidean distance, separately in each set.

sampleTrees = list()
for (set in 1:nSets)
{
sampleTrees[[set]] = hclust(dist(multiExpr[[set]]$data), method = "average")
}

#The easiest way to see the two dendrograms at the same time is to plot both into a pdf file that can be viewed using standard pdf viewers.
pdf(file = "Plot/SampleClustering_Root_Flower.pdf", width = 12, height = 12);
par(mfrow=c(2,1))
par(mar = c(0, 4, 2, 0))
for (set in 1:nSets)
plot(sampleTrees[[set]], main = paste("Sample clustering on all genes in", setLabels[set]),
xlab="", sub="", cex = 0.7);
dev.off();
save(multiExpr, TraitsCoumarin, TraitsTerpen, nGenes, nSamples, setLabels, shortLabels, exprSize,
file = "Consensus-dataInput.RData");
```


```{r}

#scripts from https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Consensus-NetworkConstruction-auto.pdf
nSets = checkSets(multiExpr)$nSets
#One-step network construction and module detection
#Choosing the soft-thresholding power: analysis of network topology
# Choose a set of soft-thresholding powers
#done in the begging ogf this page

#Network construction and consensus module detection
net = blockwiseConsensusModules(
multiExpr, power = 10, minModuleSize = 30, deepSplit = 2,
pamRespectsDendro = FALSE,
mergeCutHeight = 0.25, numericLabels = TRUE,
minKMEtoStay = 0,
saveTOMs = TRUE, verbose = 5)

#based on previous scripts we found deepSplit = 0 is better. we can try with deepSplit = 0 
net2 = blockwiseConsensusModules(
multiExpr, power = 10, minModuleSize = 30, deepSplit = 0,
pamRespectsDendro = FALSE,
mergeCutHeight = 0.25, numericLabels = TRUE,
minKMEtoStay = 0,
saveTOMs = TRUE, verbose = 5)
consMEs2 = net2$multiMEs;
moduleLabels2 = net2$colors;
moduleColors2 = labels2colors(moduleLabels2)
consTree2 = net2$dendrograms[[1]]

names(net)
# [1] "colors"                    "unmergedColors"            "multiMEs"                 
# [4] "goodSamples"               "goodGenes"                 "dendrograms"              
#[7] "TOMFiles"                  "blockGenes"                "blocks"                  
#[10] "originCount"               "networkCalibrationSamples" "individualTOMInfo"        
#[13] "consensusTOMInfo"          "consensusQuantile" 

consMEs = net$multiMEs;
moduleLabels = net$colors;
# Convert the numeric labels to color labels
moduleColors = labels2colors(moduleLabels)
consTree = net$dendrograms[[1]]

#A quick way to take a look at the results is to plot the gene dendrogram and the corresponding module colors:
sizeGrWindow(8,6);
pdf(file = "Plot/ConsensusDendrogram-auto.pdf", wi = 8, he = 6)
plotDendroAndColors(dendro = consTree, colors = moduleColors[net$blockGenes[[1]]],
      groupLabels = "Module colors",
      dendroLabels = FALSE, hang = 0.03,
      addGuide = TRUE, guideHang = 0.05,
      main = "Consensus gene dendrogram and module colors")
dev.off()

#for net2
sizeGrWindow(8,6);
pdf(file = "Plot/ConsensusDendrogram2-auto.pdf", wi = 8, he = 6)
plotDendroAndColors(dendro = consTree2, colors = moduleColors2[net2$blockGenes[[1]]],
      groupLabels = "Module colors",
      dendroLabels = FALSE, hang = 0.03,
      addGuide = TRUE, guideHang = 0.05,
      main = "Consensus gene dendrogram and module colors")
dev.off()
#for consensue net is more accurate
#Figure: Gene dendrogram obtained by clustering the dissimilarity based on consensus Topological Overlap with the corresponding module colors indicated by the color row.

save(consMEs, moduleLabels, moduleColors, consTree, file = "Consensus-NetworkConstruction-auto.RData")
save(consMEs2, moduleLabels2, moduleColors2, consTree2, file = "Consensus-NetworkConstruction2-auto.RData")
```


```{r}

#for continue this scipts need to look at https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-01-dataInput.pdf for creation some files.
#in this script start to create net just for female dataset, so I run this for root dataset
datExprroot = as.data.frame(t(rootvoom));
names(datExprroot) 
rownames(datExprroot)
nGenes = ncol(datExprroot)
nSamples = nrow(datExprroot)

#Loading trait data I have to prepare dataset for matabolites
traitData = read.csv("Metabolite_Traits.csv");
#seperate two files based on the unit of matabolite
traitDataCoumarin <-traitData[ ,c(1:2,4)] #remove UMP because all of them is zero
traitDataTerpen <-traitData[ ,c(1, 5:8)]
# See how big the traits are and what are the trait and sample names
dim(traitDataCoumarin) #18 3
names(traitDataCoumarin)
names(traitDataTerpen) 
dim(traitDataTerpen) #18 5 
# Form a data frame analogous to expression data that will hold the metabolite traits just for Coumarin.
rootSamples = rownames(datExprroot);
traitRowsCoumarin = match(rootSamples, traitDataCoumarin$Sample);
datTraitsCoumarin = traitDataCoumarin[traitRowsCoumarin, -1];
rownames(datTraitsCoumarin) = traitDataCoumarin[traitRowsCoumarin, 1];
collectGarbage();
# Form a data frame analogous to expression data that will hold the metabolite traits just for Terpen.
rootSamples = rownames(datExprroot);
traitRowsTerpen = match(rootSamples, traitDataTerpen$Sample);
datTraitsTerpen = traitDataTerpen[traitRowsTerpen, -1];
rownames(datTraitsTerpen) = traitDataTerpen[traitRowsTerpen, 1];
collectGarbage();
# Re-cluster samples
sampleTree2 = hclust(dist(datExprroot), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry for Coumarin
traitColorsCoumarin = numbers2colors(datTraitsCoumarin, signed = FALSE);
# Convert traits to a color representation: white means low, red means high, grey means missing entry for Terpen
traitColorsTerpen = numbers2colors(datTraitsTerpen, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
sizeGrWindow(7,6);
pdf(file = "Plot/SampleDendrogramTraitHeatmap.pdf", wi = 7, he = 6);
par(mfrow=c(1,1));
plotDendroAndColors(sampleTree2, traitColorsCoumarin, groupLabels = names(datTraitsCoumarin), main = "Sample dendrogram and trait heatmap")
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColorsTerpen, groupLabels = names(datTraitsTerpen), main = "Sample dendrogram and trait heatmap")
dev.off()

#In the plot,white means a low value, red a high value, and grey a missing entry.The last step is to save the relevant expression and trait data for use in the next steps of the tutorial.
save(datExprroot, datTraitsCoumarin,datTraitsTerpen, file = "Root-01-dataInput.RData")


#Automatic network construction and module detection for root 
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=20, by=2))
# Call the network topology analysis function
sft = pickSoftThreshold(datExprroot, powerVector = powers, verbose = 5)
# Plot the results:
sizeGrWindow(9, 5)
pdf(file = "Plot/scaleFreeAnalysis.pdf", wi = 9, he = 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
dev.off()

#One-step network construction and module detection for root 
#Constructing the gene network and identifying modules is now a simple function call:
netR = blockwiseModules(datExprroot, power = 10,
TOMType = "unsigned", minModuleSize = 30,
reassignThreshold = 0, mergeCutHeight = 0.25,
numericLabels = TRUE, pamRespectsDendro = FALSE,
saveTOMs = TRUE,
saveTOMFileBase = "RootTOM",
verbose = 3)

table(netR$colors) 
#   0    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19 
#  3 4509 2968  633  632  617  561  466  238  229  172  160  110  100   99   72   60   60   50   39
#The label 0 is reserved for genes outside of all modules.

#The hierarchical clustering dendrogram (tree) used for the module identification is returned in net$dendrograms[[1]]; #$.The dendrogram can be displayed together with the color assignment using the following code:

# open a graphics window
sizeGrWindow(12, 9)
pdf(file = "Plot/ConsensusDendrogramRoot-auto.pdf", wi = 12, he = 9)
# Convert labels to colors for plotting
mergedColorsR = labels2colors(netR$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(netR$dendrograms[[1]], mergedColorsR[netR$blockGenes[[1]]],
"Module colors",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
dev.off()
#We now save the module assignment and module eigengene information necessary for subsequent analysis.
moduleLabelsR = netR$colors
moduleColorsR = labels2colors(netR$colors)
MEs = netR$MEs;
MEsR <- orderMEs(MEs, greyName  = "ME0")
geneTreeR = netR$dendrograms[[1]];
save(MEsR, moduleLabelsR, moduleColorsR, geneTreeR, file = "Root-02-networkConstruction-auto.RData")
```


```{r}

#continue based https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Consensus-RelateToFemMods.pdf
# Load the data saved in the first part
lnames = load(file = "Consensus-dataInput.RData")
lnames
#The variable lnames contains the names of loaded variables.
lnames
#Relating consensus modules to root set-specific modules
#We first load the root data and rename them so that they do not conflict with the consensus data:
lnames <- load(file = "Root-02-networkConstruction-auto.RData")
lnames
# Rename variables to avoid conflicts
#add letter R at the enf of the file's name 
# Load the results of network analysis, tutorial part 2.a
#Next we load the results of the consensus module identification:
lnames = load(file = "Consensus-NetworkConstruction-auto.RData");
lnames
#The consensus network analysis results are represented by the variables consMEs, moduleLabels, moduleColors, and consTree. We are now ready to relate the root modules to the consensus modules. We calculate the overlaps of each pair of root-consensus modules, and use the Fisher’s exact test (also known as hypergeometric test) to assign a p-value to each of the pairwise overlaps.

# Isolate the module labels in the order they appear in ordered module eigengenes

rootModuleLabels = substring(names(MEsR), 3) 
consModuleLabels = substring(names(consMEs[[1]]$data), 3) 
# Convert the numeric module labels to color labels
rootModules = labels2colors(as.numeric(rootModuleLabels)) #20
consModules = labels2colors(as.numeric(consModuleLabels)) #51
# Numbers of root and consensus modules
nRootMods = length(rootModules) #20
nConsMods = length(consModules) #51
# Initialize tables of p-values and of the corresponding counts
pTable = matrix(0, nrow = nRootMods, ncol = nConsMods);
CountTbl = matrix(0, nrow = nRootMods, ncol = nConsMods);
# Execute all pairwaise comparisons
for (rmod in 1:nRootMods)
for (cmod in 1:nConsMods)
{
rootMembers = (moduleColorsR == rootModules[rmod]);
consMembers = (moduleColors == consModules[cmod]);
pTable[rmod, cmod] = -log10(fisher.test(rootMembers, consMembers, alternative = "greater")$p.value);
CountTbl[rmod, cmod] = sum(moduleColorsR == rootModules[rmod] & moduleColors ==
consModules[cmod])
}

#To display the p-value and count tables in an informative way, we create a color-coded table of the intersection counts. The colors will indicate the p-value significance:

# Truncate p values smaller than 10^{-50} to 10^{-50}
pTable[is.infinite(pTable)] = 1.3*max(pTable[is.finite(pTable)]);
#View(pTable) #row 20 col 51
pTable[pTable>50 ] = 50 ;
# Marginal counts (really module sizes)
rootModTotals = apply(CountTbl, 1, sum)
consModTotals = apply(CountTbl, 2, sum)
# Actual plotting
sizeGrWindow(19,10 );
pdf(file = "Plot/ConsensusVsRootModuless.pdf", wi = 19, he = 10);
par(mfrow=c(1,1));
par(cex = 1.0);
par(mar=c(8, 10.4, 2.7, 1)+0.3);
# Use function labeledHeatmap to produce the color-coded table with all the trimmings
labeledHeatmap(Matrix = pTable,
xLabels = paste(" ", consModules),
yLabels = paste(" ", rootModules),
colorLabels = TRUE,
xSymbols = paste("Cons ", consModules, ": ", consModTotals, sep=""),
ySymbols = paste("Root ", rootModules, ": ", rootModTotals, sep=""),
textMatrix = CountTbl,
colors = greenWhiteRed(100)[50:100],
main = "Correspondence of Root set-specific and Root-Flower consensus modules",
cex.text = 1.0, cex.lab = 1.0, setStdMargins = FALSE);
dev.off()
#Figure: Correspondence of root set-specific modules and the root-flower consensus modules. Each row of the table corresponds to one root set-specific module (labeled by color as well as text), and each column corresponds to one consensus module. Numbers in the table indicate gene counts in the intersection of the corresponding modules. Coloring of the table encodes − log(p), with p being the Fisher’s exact test p-value for the overlap of the two modules. The stronger the red color, the more significant the overlap is.
#The table indicates that most root set-specific modules have a consensus counterpart or not???.
```


```{r}

#Scripts based on https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Consensus-RelateModsToTraits.pdf

lnames = load(file = "Consensus-dataInput.RData");
# Also load results of network analysis
lnames = load(file = "Consensus-NetworkConstruction-auto.RData");
lnames
exprSize = checkSets(multiExpr);
nSets = exprSize$nSets;
#In this section we illustrate the use of module eigengenes to relate consensus modules to matabolite traits. In this analysis we relate the traits to consensus module eigengenes in each of the two sets. We remind the reader that while the consensus modules is a single module assignment for all genes, the module eigengenes represent the modules in each of the two sets. In other words, we have a single module assignment for each gene, but we have two sets of consensus module eigengenes, because a given module (set of genes) has a particular expression profile in the root, and a different expression profile in the flower. Similarly, we have the trait data separately for the root and flower.
# Set up variables to contain the module-trait correlations, Coumarin
moduleTraitCoumarinCor = list();
moduleTraitCoumarinPvalue = list();
# Calculate the correlations
for (set in 1:nSets)
{
moduleTraitCoumarinCor[[set]] = cor(consMEs[[set]]$data, TraitsCoumarin[[set]]$data, use = "p");
moduleTraitCoumarinPvalue[[set]] = corPvalueFisher(moduleTraitCoumarinCor[[set]], exprSize$nSamples[set]);
}

#We now display the module-trait relationships using a color-coded table. We print the correlations and the corresponding p-values, and color-code the entris by the p-value significance.
# Convert numerical lables to colors for labeling of modules in the plot
MEColors = labels2colors(as.numeric(substring(names(consMEs[[1]]$data), 3)));
MEColorNames = paste("ME", MEColors, sep="");
# Open a suitably sized window (the user should change the window size if necessary)
sizeGrWindow(14,15)
pdf(file = "Plot/ModuleTraitRelationships-root.pdf", wi = 14, he = 15);
# Plot the module-trait relationship table for set number 1
set = 1
textMatrix = paste(signif(moduleTraitCoumarinCor[[set]], 2), "\n(",
signif(moduleTraitCoumarinPvalue[[set]], 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCoumarinCor[[set]])
par(mar = c(6, 10, 3, 2.2));
labeledHeatmap(Matrix = moduleTraitCoumarinCor[[set]],
xLabels = names(TraitsCoumarin[[set]]$data),
yLabels = MEColorNames,
ySymbols = MEColorNames,
colorLabels = FALSE,
colors = greenWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Module--trait relationships in", setLabels[set]))
dev.off();

# Plot the module-trait relationship table for set number 2
set = 2
textMatrix = paste(signif(moduleTraitCoumarinCor[[set]], 2), "\n(",
signif(moduleTraitCoumarinPvalue[[set]], 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCoumarinCor[[set]])
sizeGrWindow(14,15)
pdf(file = "Plot/ModuleTraitRelationships-flower.pdf", wi = 14, he = 15);
par(mar = c(6, 10, 3, 2.2));
labeledHeatmap(Matrix = moduleTraitCoumarinCor[[set]],
xLabels = names(TraitsCoumarin[[set]]$data),
yLabels = MEColorNames,
ySymbols = MEColorNames,
colorLabels = FALSE,
colors = greenWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Module--trait relationships in", setLabels[set]))
dev.off();
#Figure : Relationships of consensus module eigengenes and metabolites traits in the flower data. Each row in the table corresponds to a consensus module, and each column to a trait. Numbers in the table report the correlations of the corresponding module eigengenes and traits, with the p-values printed below the correlations in parentheses. The table is color coded by correlation according to the color legend.

#The two tables are shown in Figs. 1 and 2. The two module-trait relationship tables look similar but they arenot the same. For example, they both identify the ... modules as highly related to matabolite, although the actual correlations and p-values differ slightly. There are several ways of forming a measure of module-trait relationships that summarizes the two sets into one measure. We will form a very conservative one: for each module-trait pair we take the correlation that has the lower absolute value in the two sets if the two correlations have the same sign, and zero relationship if the two correlations have opposite signs:

# Initialize matrices to hold the consensus correlation and p-value
consensusCoumrinCor = matrix(NA, nrow(moduleTraitCoumarinCor[[1]]), ncol(moduleTraitCoumarinCor[[1]]));
consensusCoumrinPvalue = matrix(NA, nrow(moduleTraitCoumarinPvalue[[1]]), ncol(moduleTraitCoumarinPvalue[[1]]));
# Find consensus negative correlations
negative = moduleTraitCoumarinCor[[1]] < 0 & moduleTraitCoumarinCor[[2]] < 0;
consensusCoumrinCor[negative] = pmax(moduleTraitCoumarinCor[[1]][negative], moduleTraitCoumarinCor[[2]][negative]);
consensusCoumrinPvalue[negative] = pmax(moduleTraitCoumarinPvalue[[1]][negative], moduleTraitCoumarinPvalue[[2]][negative]);
# Find consensus positive correlations
positive = moduleTraitCoumarinCor[[1]] > 0 & moduleTraitCoumarinCor[[2]] > 0;
consensusCoumrinCor[positive] = pmin(moduleTraitCoumarinCor[[1]][positive], moduleTraitCoumarinCor[[2]][positive]);
consensusCoumrinPvalue[positive] = pmax(moduleTraitCoumarinPvalue[[1]][positive], moduleTraitCoumarinPvalue[[2]][positive]);

#We display the consensus module–trait relationships again using a color-coded table:
textMatrixCoumarin = paste(signif(consensusCoumrinCor, 2), "\n(",
signif(consensusCoumrinPvalue, 1), ")", sep = "");
dim(textMatrixCoumarin) = dim(moduleTraitCoumarinCor[[set]])
sizeGrWindow(14,15)
pdf(file = "Plot/ModuleTraitRelationships-consensus.pdf", wi = 14, he = 15);
par(mar = c(6, 10, 3, 2.2));
labeledHeatmap(Matrix = consensusCoumrinCor,
xLabels = names(TraitsCoumarin[[set]]$data),
yLabels = MEColorNames,
ySymbols = MEColorNames,
colorLabels = FALSE,
colors = greenWhiteRed(50),
textMatrix = textMatrixCoumarin,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Consensus module--trait relationships across\n",
paste(setLabels, collapse = " and ")))
dev.off()

#Figure :Consensus relationships of consensus module eigengenes and matabolite traits across the root and flower data. Each row in the table corresponds to a consensus module, and each column to a trait. Numbers in the table report the consensus correlations of the corresponding module eigengenes and traits, with the p-values printed below the correlations in parentheses. The table is color coded by correlation according to the color legend. Missing (NA) entries indicate that the correlations in the root and flower data sets have opposite signs and no consensus can be formed.

# The advantage of the consensus relationship table is that it isolates the module-trait relationships that are present in both sets, and hence may be in a sense considered validated. For example, we confirm that the .... modules are highly related to ...metabolite in both sets; the ... module is highly related to ... levels etc. One could now adapt the gene selection technique illustrated in the female expression analysis tutorial to look for particular genes that are highly related to traits as well as being highly connected in a module related to the trait.

# Set up variables to contain the module-trait correlations for Terpen
moduleTraitTerpenCor = list();
moduleTraitTerpenPvalue = list();
# Calculate the correlations
for (set in 1:nSets)
{
moduleTraitTerpenCor[[set]] = cor(consMEs[[set]]$data, TraitsTerpen[[set]]$data, use = "p");
moduleTraitTerpenPvalue[[set]] = corPvalueFisher(moduleTraitTerpenCor[[set]], exprSize$nSamples[set]);
}

#We now display the module-trait relationships using a color-coded table. We print the correlations and the corresponding p-values, and color-code the entris by the p-value significance.
# Convert numerical lables to colors for labeling of modules in the plot
MEColors = labels2colors(as.numeric(substring(names(consMEs[[1]]$data), 3)));
MEColorNames = paste("ME", MEColors, sep="");
# Open a suitably sized window (the user should change the window size if necessary)
sizeGrWindow(14,15)
pdf(file = "Plot/ModuleTerpenTraitRelationships-root.pdf", wi = 14, he = 15);
# Plot the module-trait relationship table for set number 1
set = 1
textMatrix = paste(signif(moduleTraitTerpenCor[[set]], 2), "\n(",
signif(moduleTraitTerpenPvalue[[set]], 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitTerpenCor[[set]])
par(mar = c(6, 10, 3, 2.2));
labeledHeatmap(Matrix = moduleTraitTerpenCor[[set]],
xLabels = names(TraitsTerpen[[set]]$data),
yLabels = MEColorNames,
ySymbols = MEColorNames,
colorLabels = FALSE,
colors = greenWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Module--trait relationships in", setLabels[set]))
dev.off();
#Figure : Relationships of consensus module eigengenes and metabolites traits in the root data. Each row in the table corresponds to a consensus module, and each column to a trait. Numbers in the table report the correlations of the corresponding module eigengenes and traits, with the p-values printed below the correlations in parentheses. The table is color coded by correlation according to the color legend

# Plot the module-trait relationship table for set number 2
set = 2
textMatrix = paste(signif(moduleTraitTerpenCor[[set]], 2), "\n(",
signif(moduleTraitTerpenPvalue[[set]], 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitTerpenCor[[set]])
sizeGrWindow(14,15)
pdf(file = "Plot/ModuleTerpenTraitRelationships-flower.pdf", wi = 14, he = 15);
par(mar = c(6, 10, 3, 2.2));
labeledHeatmap(Matrix = moduleTraitTerpenCor[[set]],
xLabels = names(TraitsTerpen[[set]]$data),
yLabels = MEColorNames,
ySymbols = MEColorNames,
colorLabels = FALSE,
colors = greenWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Module--trait relationships in", setLabels[set]))
dev.off();

#Figure : Relationships of consensus module eigengenes and metabolites traits in the flower data. Each row in the table corresponds to a consensus module, and each column to a trait. Numbers in the table report the correlations of the corresponding module eigengenes and traits, with the p-values printed below the correlations in parentheses. The table is color coded by correlation according to the color legend.

#The two module-trait relationship tables look similar but they are not the same. For example, they both identify the ???? modules as highly related to....metabolites, although the actual correlations and p-values differ slightly. There are several ways of forming a measure of module-trait relationships that summarizes the two sets into one measure. We will form a very conservative one: for each module-trait pair we take the correlation that has the lower absolute value in the two sets if the two correlations have the same sign, and zero relationship if the two correlations have opposite signs:

# Initialize matrices to hold the consensus correlation and p-value
consensusTerpenCor = matrix(NA, nrow(moduleTraitTerpenCor[[1]]), ncol(moduleTraitTerpenCor[[1]]));
consensusTerpenPvalue = matrix(NA, nrow(moduleTraitTerpenPvalue[[1]]), ncol(moduleTraitTerpenPvalue[[1]]));
# Find consensus negative correlations
negative = moduleTraitCoumarinCor[[1]] < 0 & moduleTraitCoumarinCor[[2]] < 0;
consensusCoumrinCor[negative] = pmax(moduleTraitCoumarinCor[[1]][negative], moduleTraitCoumarinCor[[2]][negative]);
consensusCoumrinPvalue[negative] = pmax(moduleTraitCoumarinPvalue[[1]][negative], moduleTraitCoumarinPvalue[[2]][negative]);
# Find consensus positive correlations
positive = moduleTraitCoumarinCor[[1]] > 0 & moduleTraitCoumarinCor[[2]] > 0;
consensusCoumrinCor[positive] = pmin(moduleTraitCoumarinCor[[1]][positive], moduleTraitCoumarinCor[[2]][positive]);
consensusCoumrinPvalue[positive] = pmax(moduleTraitCoumarinPvalue[[1]][positive], moduleTraitCoumarinPvalue[[2]][positive]);

#We display the consensus module–trait relationships again using a color-coded table:
textMatrixCoumarin = paste(signif(consensusCoumrinCor, 2), "\n(",
signif(consensusCoumrinPvalue, 1), ")", sep = "");
dim(textMatrixCoumarin) = dim(moduleTraitCoumarinCor[[set]])
sizeGrWindow(14,15)
pdf(file = "Plot/ModuleTraitRelationships-consensus.pdf", wi = 14, he = 15);
par(mar = c(6, 10, 3, 2.2));
labeledHeatmap(Matrix = consensusCoumrinCor,
xLabels = names(TraitsCoumarin[[set]]$data),
yLabels = MEColorNames,
ySymbols = MEColorNames,
colorLabels = FALSE,
colors = greenWhiteRed(50),
textMatrix = textMatrixCoumarin,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Consensus module--trait relationships across\n",
paste(setLabels, collapse = " and ")))
dev.off()

#4.a Exporting results of the network analysis
#need annotation data???back after blast2go or trinotate
```


```{r}

#scripts from https://labs.genetics.ucla.edu/horvath/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Consensus-EigengeneNetworks.pdf

# Basic settings: we work with two data sets
nSets = 2;
# For easier labeling of plots, create a vector holding descriptive names of the two sets.
setLabels = c("Root", "Flower")
shortLabels = c("Root", "Flower")
# Load the data saved in the first part
lnames = load(file = "Consensus-dataInput.RData");
#The variable lnames contains the names of loaded variables.
lnames
# Load the results of network analysis
lnames = load(file = "Consensus-NetworkConstruction-auto.RData");
lnames
#Comparing eigengene networks in root and flower
#In this section we compare the consensus eigengene networks in the root and female data sets (such comparison is often called differential analysis). Consensus eigengene networks capture the relationships among consensus modules; the relationships are quantified by eigengene correlations. We first extend the consensus eigengenes by adding the coumarin and terpen trait as an additional “eigengene”:
# Create a variable coumarin that will hold just the UMF in both sets
coumarin = vector(mode = "list", length = nSets);
for (set in 1:nSets)
{
coumarin[[set]] = list(data = as.data.frame(TraitsCoumarin[[set]]$data$UMF));
names(coumarin[[set]]$data) = "coumarin"
}
# Recalculate consMEs to give them color names
consMEsC = multiSetMEs(multiExpr, universalColors = moduleColors);
# We add the coumarin trait to the eigengenes and order them by consesus hierarchical clustering:
MET = consensusOrderMEs(addTraitToMEs(consMEsC, coumarin));

#We now call the function plotEigengeneNetworks that performs the differential analysis:
sizeGrWindow(20,12);
pdf(file = "Plot/EigengeneNetworks_CoumarinUMF.pdf", width= 20, height = 12);
par(cex = 0.9)
plotEigengeneNetworks(MET, setLabels ,marDendro = c(3,3,2,1), marHeatmap = c(5,4,2,1),
zlimPreservation = c(0.5, 1), xLabelsAngle = 90)
dev.off();
#Figure: Summary plot of consensus eigengene networks and their differential analysis. The top two panels show the dendrograms (clustering trees) of the consensus module eigengenes in the two sets indicated in the titles. Below, the eigengene networks in the two sets are shown as heatmaps labeled Root and Flower. In the heatmaps, red denotes high adjacency (positive correlation) and green denotes low adjacency (negative correlation). The Preservation heatmap shows the preservation network, defined as one minus the absolute difference of the eigengene networks in the two data sets. The barplot shows the mean preservation of adjacency for each of the eigengenes to all other eigengenes; in other words, the barplot depicts the column means of the preservation heatmap.

#The plot is shown in Fig. 1. The plot shows the eigengene dendrograms and eigengene network heatmaps, as well as two plots of network preservation between the two sets, namely a heatmap plot of the preservation adjacency [1] and a barplot of mean preservation of relationships for each eigengene. The overall preservation of the two eigengene networks is 0.65, which  means the preserbation is not very high. A visual inspection of the root and flower network heatmap plots indicates that the inter-module relationships in the two data sets are indeed very similar. The red blocks along the diagonal in the network heatmaps indicate meta-modules, groups of correlated eigengenes, and these are largely preserved between the two sets. The preservation heatmap and barplots indicate that most relationships are very highly preserved. The message here is that inter-module relationships are strongly preserved across similar data sets and encode biologically meaningful information.

# Basic settings: we work with two data sets (try for luteolin)
nSets = 2;
# For easier labeling of plots, create a vector holding descriptive names of the two sets.
setLabels = c("Root", "Flower")
shortLabels = c("Root", "Flower")
# Load the data saved in the first part
lnames = load(file = "Consensus-dataInput.RData");
#The variable lnames contains the names of loaded variables.
lnames
# Load the results of network analysis
lnames = load(file = "Consensus-NetworkConstruction-auto.RData");
lnames
#Comparing eigengene networks in root and flower
#In this section we compare the consensus eigengene networks in the root and female data sets (such comparison is often called differential analysis). Consensus eigengene networks capture the relationships among consensus modules; the relationships are quantified by eigengene correlations. We first extend the consensus eigengenes by adding the coumarin and terpen trait as an additional “eigengene”:
# Create a variable coumarin that will hold just the Luteolin in both sets
coumarin = vector(mode = "list", length = nSets);
for (set in 1:nSets)
{
coumarin[[set]] = list(data = as.data.frame(TraitsCoumarin[[set]]$data$Luteolin));
names(coumarin[[set]]$data) = "coumarin"
}
# Recalculate consMEs to give them color names
consMEsC = multiSetMEs(multiExpr, universalColors = moduleColors);
# We add the coumarin trait to the eigengenes and order them by consesus hierarchical clustering:
MET = consensusOrderMEs(addTraitToMEs(consMEsC, coumarin));

#We now call the function plotEigengeneNetworks that performs the differential analysis:
sizeGrWindow(20,12);
pdf(file = "Plot/EigengeneNetworks_CoumarinLuteolin.pdf", width= 20, height = 12);
par(cex = 0.9)
plotEigengeneNetworks(MET, setLabels ,marDendro = c(3,3,2,1), marHeatmap = c(5,4,2,1),
zlimPreservation = c(0.5, 1), xLabelsAngle = 90)
dev.off();

# Create a variable Terpen that will hold just the HM in both sets
terpen = vector(mode = "list", length = nSets);
for (set in 1:nSets)
{
terpen[[set]] = list(data = as.data.frame(TraitsTerpen[[set]]$data$HM));
names(terpen[[set]]$data) = "terpen"
}
# Recalculate consMEs to give them color names
consMEsC = multiSetMEs(multiExpr, universalColors = moduleColors);
# We add the terpen trait to the eigengenes and order them by consesus hierarchical clustering:
MET = consensusOrderMEs(addTraitToMEs(consMEsC,terpen));

#We now call the function plotEigengeneNetworks that performs the differential analysis:
sizeGrWindow(20,12);
pdf(file = "Plot/EigengeneNetworks_TerpenHM.pdf", width= 20, height = 12);
par(cex = 0.9)
plotEigengeneNetworks(MET, setLabels ,marDendro = c(3,3,2,1), marHeatmap = c(5,4,2,1),
zlimPreservation = c(0.5, 1), xLabelsAngle = 90)
dev.off();

# Create a variable Terpen that will hold just the HS in both sets
terpen = vector(mode = "list", length = nSets);
for (set in 1:nSets)
{
terpen[[set]] = list(data = as.data.frame(TraitsTerpen[[set]]$data$HS));
names(terpen[[set]]$data) = "terpen"
}
# Recalculate consMEs to give them color names
consMEsC = multiSetMEs(multiExpr, universalColors = moduleColors);
# We add the terpen trait to the eigengenes and order them by consesus hierarchical clustering:
MET = consensusOrderMEs(addTraitToMEs(consMEsC,terpen));

#We now call the function plotEigengeneNetworks that performs the differential analysis:
sizeGrWindow(20,12);
pdf(file = "Plot/EigengeneNetworks_TerpenHS.pdf", width= 20, height = 12);
par(cex = 0.9)
plotEigengeneNetworks(MET, setLabels ,marDendro = c(3,3,2,1), marHeatmap = c(5,4,2,1),
zlimPreservation = c(0.5, 1), xLabelsAngle = 90)
dev.off();

# Create a variable Terpen that will hold just the OS in both sets
terpen = vector(mode = "list", length = nSets);
for (set in 1:nSets)
{
terpen[[set]] = list(data = as.data.frame(TraitsTerpen[[set]]$data$OS));
names(terpen[[set]]$data) = "terpen"
}
# Recalculate consMEs to give them color names
consMEsC = multiSetMEs(multiExpr, universalColors = moduleColors);
# We add the terpen trait to the eigengenes and order them by consesus hierarchical clustering:
MET = consensusOrderMEs(addTraitToMEs(consMEsC,terpen));

#We now call the function plotEigengeneNetworks that performs the differential analysis:
sizeGrWindow(20,12);
pdf(file = "Plot/EigengeneNetworks_TerpenOS.pdf", width= 20, height = 12);
par(cex = 0.9)
plotEigengeneNetworks(MET, setLabels ,marDendro = c(3,3,2,1), marHeatmap = c(5,4,2,1),
zlimPreservation = c(0.5, 1), xLabelsAngle = 90)
dev.off();
```
